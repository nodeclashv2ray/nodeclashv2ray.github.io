<!doctype html>
<html xml:lang="zh-CN" lang="zh-CN">

<head>
        <link rel="canonical" href="https://nodeclashv2ray.github.io/news/article-86773.htm" />
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <title>vue中的共享数据管理vuex</title>
        <meta name="description" content="引言 &nbsp; &nbsp; &nbsp; &nbsp; vuex是关于对vue中一些多个组件共享的数据进行统一集中式管理的方法。在实际的前端开发中，为了减少重复代码的使用，通常我们会把重复使用的" />
        <link rel="icon" href="/assets/website/img/nodeclashv2ray/favicon.ico" type="image/x-icon"/>

    <meta name="author" content="NodeClashV2ray节点订阅站">
    <meta property="og:type" content="article" />
    <meta property="og:url" content="https://nodeclashv2ray.github.io/news/article-86773.htm" />
    <meta property="og:site_name" content="NodeClashV2ray节点订阅站" />
    <meta property="og:title" content="vue中的共享数据管理vuex" />
    <meta property="og:image" content="https://nodeclashv2ray.github.io/uploads/20240509/17d5372a8f47e2dbc7a17a56557bf8d9.webp" />
        <meta property="og:release_date" content="2025-04-02T07:44:27" />
    <meta property="og:updated_time" content="2025-04-02T07:44:27" />
        <meta property="og:description" content="引言 &nbsp; &nbsp; &nbsp; &nbsp; vuex是关于对vue中一些多个组件共享的数据进行统一集中式管理的方法。在实际的前端开发中，为了减少重复代码的使用，通常我们会把重复使用的" />
        
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <!-- Place favicon.ico in the root directory -->
    <!-- All css files are included here. -->

    <meta name="applicable-device" content="pc,mobile" />
    <meta name="renderer" content="webkit" />
    <meta name="force-rendering" content="webkit" />
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta name="robots" content="max-image-preview:large" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="vue中的共享数据管理vuex">
    <meta name="format-detection" content="telephone=no">

    <link rel="dns-prefetch" href="https:/www.googletagmanager.com">
    <link rel="dns-prefetch" href="https://www.googleadservices.com">
    <link rel="dns-prefetch" href="https://www.google-analytics.com">
    <link rel="dns-prefetch" href="https://pagead2.googlesyndication.com">
    <link rel="dns-prefetch" href="https://cm.g.doubleclick.net">
    
    <!-- Bootstrap fremwork main css -->
    <link rel="stylesheet" href="/assets/website/css/nodeclashv2ray/bootstrap.min.css">
    <!-- This core.css file contents all plugings css file. -->
    <link rel="stylesheet" href="/assets/website/css/nodeclashv2ray/core.css">
    <!-- Theme shortcodes/elements style -->
    <link rel="stylesheet" href="/assets/website/css/nodeclashv2ray/shortcode/shortcodes.css">
    <!-- Theme main style -->
    <link rel="stylesheet" href="/assets/website/css/nodeclashv2ray/style.css">
    <!-- Responsive css -->
    <link rel="stylesheet" href="/assets/website/css/nodeclashv2ray/responsive.css">
    <!-- Style customizer (Remove these two lines please) -->
    <link rel="stylesheet" href="/assets/website/css/nodeclashv2ray/style-customizer.css">
    <!-- User style -->
    <link rel="stylesheet" href="/assets/website/css/nodeclashv2ray/custom.css">
    <!-- Modernizr JS -->
    <script src="/assets/website/js/frontend/nodeclashv2ray/vendor/modernizr-2.8.3.min.js"></script>
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-BKWDB6T1Z4"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-BKWDB6T1Z4');
</script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3332997411212854"
     crossorigin="anonymous"></script>
</head>

<body data-page="detail">
    <!--[if lt IE 8]>
        <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>
    <![endif]-->
    <!-- Body main wrapper start -->
    <div class="wrapper">
        <!-- Start of Header Top Area -->
        <header id="header-content">
            <!-- Start of mainmenu area -->
            <div id="sticky-header-with-topbar" class="header-bottom-area bg-white height-100  transparent-header hidden-xs">
                <div class="container">
                    <div class="row">
                        <div class="col-md-5 col-sm-12">
                            <div class="logo f-left sm-center">
                                <a href="/">
                                                                <span>Node Clash V2ray</span>
                                                                </a>
                            </div>
                        </div>
                        <div class="col-md-7 col-sm-12">
                            <div class="mainmenu-container">
                                <ul class="main-menu">
                                                                        <li><a href="/">首页</a></li>
                                                                        <li><a href="/free-nodes/">免费节点</a></li>
                                                                        <li><a href="/paid-subscribe/">推荐机场</a></li>
                                                                        <li><a href="/client.htm">客户端</a></li>
                                                                        <li><a href="/news/">新闻资讯</a></li>
                                                                    </ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Mobile-menu-area start -->
            <div class="mobile-menu-area hidden-md hidden-lg hidden-sm">
                <div class="fluid-container mobile-menu-container">
                    <div class="mobile-logo">
                                                <a href="/">Node Clash V2ray</a>
                                            </div>
                    <div class="mobile-menu clearfix">
                        <nav id="mobile_dropdown">
                            <ul>
                                                                <li><a href="/">首页</a></li>
                                                                <li><a href="/free-nodes/">免费节点</a></li>
                                                                <li><a href="/paid-subscribe/">推荐机场</a></li>
                                                                <li><a href="/client.htm">客户端</a></li>
                                                                <li><a href="/news/">新闻资讯</a></li>
                                                            </ul>
                        </nav>
                    </div>
                </div>
            </div>
            <!-- Mobile-menu-area end -->
        </header>
<!-- End of Header Top Area -->
        <!-- Start Bradcaump area -->
        <div class="tf-bradcaump-area sbg-3" data-black-overlay="8">
            <div class="container">
                <div class="row">
                    <div class="col-xs-12">
                        <div class="bradcaump-wrap text-center">
                            <h1 class="bradcaump-title">vue中的共享数据管理vuex</h1>
                            <nav class="bradcaump-inner">
                                <a class="breadcrumb-item" href="/">首页</a>
                                <span class="brd-separetor">/</span>
                                <a class="breadcrumb-item" href="/news/">新闻资讯</a>
                                <span class="brd-separetor">/</span>
                                <span class="breadcrumb-item active">正文</span>
                            </nav>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <!-- End Bradcaump area -->
        <section id="tf-about-container" class="tf-about-area ptb-100 bg-gray xtb-60">
            <div class="container">
                <div class="row">
                    <div class="col-md-9">
                                        <input type="hidden" id="share-website-info" data-name="" data-url="">
                  				  				  				<div id="content_views" class="htmledit_views"> <p><strong>引言</strong></p> <p>&nbsp; &nbsp; &nbsp; &nbsp; vuex是关于对vue中一些多个组件共享的数据进行统一集中式管理的方法。在实际的前端开发中，为了减少重复代码的使用，通常我们会把重复使用的代码，封装成一个组件。不同组件之间一定会存在着数据共享传值的情况。如果数据传值频繁了，会很难控制数据的状态，很难统一协调维护。针对此情况，vue中诞生出了 vuex状态管理工具，react中是redux管理工具。vuex将全局管理共享的数据，统一集中式管理共享数据的状态。</p> <p>&nbsp; &nbsp; &nbsp; &nbsp; 官宣：从vue思想角度考虑，状态管理包含三个部分： state、view、actions。state是驱动应用的数据源，view，以声明方式将state映射到视图，actions，响应在view上的用户输入导致的状态变化。</p> <p><img fetchpriority="high" decoding="async" alt="" height="300" src="http://img.555519.xyz/uploads3/20220606/df940c4ff84d544d29331b3d5619070f.jpg"></p> <p>&nbsp; &nbsp; &nbsp; &nbsp; 当我们的应用遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏：</p> <ul> <li>多个视图依赖于同一状态</li> <li>来自不同视图的行为需要变更同一状态</li> </ul> <p>&nbsp; &nbsp; &nbsp; &nbsp; 那么，问题来了，传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。</p> <p>&nbsp; &nbsp; &nbsp; &nbsp; 针对上面的问题，vuex中的解决办法：把组件的共享状态抽取出来，以一个全局单例模式管理。在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为。</p> <p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;通过定义和隔离状态管理中的各种概念并通过强制规则维持视图和状态间的独立性，我们的代码将会变得更结构化且易维护。这就是vux背后的基本思想。</p> </h1> <p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p> <p><img decoding="async" alt="" height="492" src="http://img.555519.xyz/uploads3/20220606/99bf8edbf5e27eaef3d8637d532b8c4a.jpg"></p> <p>&nbsp; &nbsp; &nbsp; &nbsp; Vuex 可以帮助我们管理共享状态，并附带了更多的概念和框架。这需要对短期和长期效益进行权衡。如果开发大型单页应用，使用 Vuex 可能是繁琐冗余的，一个简单的<a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://cn.vuejs.org/v2/guide/state-management.html#%E7%AE%80%E5%8D%95%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E8%B5%B7%E6%AD%A5%E4%BD%BF%E7%94%A8"  rel="nofollow">store 模式&nbsp;(opens new window)</a>就可以满足所需。如果要构建一个中大型单页应用，大有可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。</p> <p>&nbsp; &nbsp; &nbsp; 一个简单的store代码案例，如下</p> <ol> <li>执行 ' vue create hello-world' 命令，创建一个 简单的 hello-world 项目框架，目录结构如下</li> </ol> <p><img decoding="async" alt="" height="561" src="http://img.555519.xyz/uploads3/20220606/48b017d65a757321c451f5995f16d5cb.jpg"></p> <p><strong>2.</strong>不同文件中的内容如下：</p> <p>Hello-world.vue</p> <pre><code>&lt;template&gt;   &lt;div class="hello"&gt;     &lt;h1&gt;{<!-- -->{ msg }}&lt;/h1&gt;     &lt;h1&gt;应用store中的 count {<!-- -->{ num }}&lt;/h1&gt;     &lt;p&gt;       For a guide and recipes on how to configure / customize this project,&lt;br&gt;       check out the       &lt;a href="https://cli.vuejs.org" target="_blank" &gt;vue-cli documentation&lt;/a&gt;.     &lt;/p&gt;     &lt;h3&gt;Installed CLI Plugins&lt;/h3&gt;     &lt;ul&gt;       &lt;li&gt;&lt;a href="https://github.com/vuejs/vue-cli/tree/dev/packages/%40vue/cli-plugin-babel" target="_blank" &gt;babel&lt;/a&gt;&lt;/li&gt;       &lt;li&gt;&lt;a href="https://github.com/vuejs/vue-cli/tree/dev/packages/%40vue/cli-plugin-eslint" target="_blank" &gt;eslint&lt;/a&gt;&lt;/li&gt;     &lt;/ul&gt;   &lt;/div&gt; &lt;/template&gt;  &lt;script&gt; export default {   name: 'HelloWorld',   props: {     msg: String   },   data(){     return {       num:this.$store.state.count     }   } } &lt;/script&gt;  &lt;!-- Add "scoped" attribute to limit CSS to this component only --&gt; &lt;style scoped&gt; h3 {   margin: 40px 0 0; } ul {   list-style-type: none;   padding: 0; } li {   display: inline-block;   margin: 0 10px; } a {   color: #42b983; } &lt;/style&gt;</code></pre> <p>App.vue</p> <pre><code>&lt;template&gt;   &lt;div id="app"&gt;     &lt;img alt="Vue logo" src="./assets/logo.png" alt="vue中的共享数据管理vuex"&gt;     &lt;HelloWorld msg="Welcome to Your Vue.js App"/&gt;   &lt;/div&gt; &lt;/template&gt;  &lt;script&gt; import HelloWorld from './components/HelloWorld.vue'  export default {   name: 'App',   components: {     HelloWorld   } } &lt;/script&gt;  &lt;style&gt; #app {   font-family: Avenir, Helvetica, Arial, sans-serif;   -webkit-font-smoothing: antialiased;   -moz-osx-font-smoothing: grayscale;   text-align: center;   color: #2c3e50;   margin-top: 60px; } &lt;/style&gt;</code></pre> <p>main.js</p> <pre><code>import Vue from 'vue' import App from './App.vue' import store from './store'  Vue.config.productionTip = false  new Vue({   render: h =&gt; h(App),   store,   components: { App },   template: '&lt;App/&gt;' }).$mount('#app')</code></pre> <p>store.js</p> <pre><code>import Vue from 'vue' import Vuex from 'vuex'  Vue.use(Vuex)  let store = new Vuex.Store({     state:{         count:1     } })  export default store</code></pre> </h1> <h2>2.1&nbsp; State</h2> <p>&nbsp; &nbsp; &nbsp; &nbsp; Vuex使用单一状态树，用一个状态包含了全部的应用层级状态。每个应用仅仅包含一个store实例。单一状态树可以支持定位任一特定的状态片段，在调试过程中也能容易获取整个当前应用状态的快照。</p> <pre><code>const counter = {     template: `&lt;div&gt;{<!-- -->{ count }}&lt;/div&gt;`,     computed: {         count () {             return store.state.count         }     } }</code></pre> <p>&nbsp; &nbsp; &nbsp; &nbsp; 每当 store.state.count 变化的时候，都会重新求取计算属性，并且触发更新相关联的DOM。这种模式导致组件全局状态单例，在模块化的构建系统中，在每个需要使用state的组件中需要频繁导入，并且在测试组件时需要模拟状态。</p> <p>&nbsp; &nbsp; &nbsp; &nbsp;Vuex通过 store选项，提供了一种机制将状态从根组件注入到每一个子组件中&nbsp; Vue.use(Vuex)</p> <pre><code>const app = new Vue({   el: '#app',   // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件   store,   components: { Counter },   template: `     &lt;div class="app"&gt;       &lt;counter&gt;&lt;/counter&gt;     &lt;/div&gt;   ` })</code></pre> <p>&nbsp; &nbsp; &nbsp; 通过在根实例注册 store&nbsp;选项，该 store&nbsp;实例会注入到根组件下的所有子组件中，且子组件能通过this.$store访问到。让我们更新下Counter的实现</p> <pre><code>const Counter = {   template: `&lt;div&gt;{<!-- -->{ count }}&lt;/div&gt;`,   computed: {     count () {       return this.$store.state.count     }   } }</code></pre> <h3>2.1.1&nbsp; mapState辅助函数</h3> <p>&nbsp; &nbsp; &nbsp; &nbsp; 当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗杂。</p> <pre><code>// 在单独构建的版本中辅助函数为 Vuex.mapState import { mapState } from 'vuex'  export default {   // ...   computed: mapState({     // 箭头函数可使代码更简练     count: state =&gt; state.count,      // 传字符串参数 'count' 等同于 `state =&gt; state.count`     countAlias: 'count',      // 为了能够使用 `this` 获取局部状态，必须使用常规函数     countPlusLocalState (state) {       return state.count + this.localCount     }   }) }</code></pre> <p>&nbsp; &nbsp; &nbsp; &nbsp; 当映射的计算属性的名称与state的子节点名称相同时，我们可以给mapState传一个字符串数组。</p> <pre><code>computed: mapState([   // 映射 this.count 为 store.state.count   'count' ])</code></pre> <p><strong>对象展开运算符</strong>mapstate函数返回的是一个对象。我们如何将它和局部计算属性混合使用？通常我们需要需要一个工具函数将多个对象合并为一个，以使我们可以将最终对象传给 computed属性。对象展开符可以简化这个写法</p> <pre><code>computed: {     localComputed(){ //... },     ...mapstate({         //...     }) }</code></pre> <p id="components-can-still-have-local-state"><strong><span style="color:#2c3e50;">组件仍可以具有本地状态</span></strong><span style="color:#2c3e50;">使用Vuex并不意味着您将所有状态放入Vuex中。如果一个状态属于一个单一组件，那么将其保留为本地状态就可以了。在实际开发中，可以权衡是加入全局的Vuex中，还是单个组件的Vuex中。</span></p> <h2><span style="color:#2c3e50;">2.2 Getters</span></h2> <p><span style="color:#2c3e50;">&nbsp; &nbsp; &nbsp; &nbsp; 有时我们可能要根据存储状态来计算派生状态，例如，通过项目列表进行过滤并进行计数。</span></p> <pre><code>computed: {     doneTodosCount(){         return this.$store.state.todo.filter(todo =&gt; todo.done).length     } }</code></pre> <p>如果在多个组件中使用上面的状态函数，还需要复制多分放在不同的组件中。针对此，Vuex允许我们在store中定义 getters.,可以将其视为 store的计算属性，getter的结果根据其依赖关系进行缓存，并且仅在其依赖关系发生变更时，重新进行计算。</p> <pre><code>const store = new Vuex.Store({     state: {         todos:[             {id:1, text:'...',done:true},             {id:2,text:'...',done:false}         ]     },     getters:{         doneTodos:state =&gt; {             return state.todos.filter(todo =&gt; todo.done)         }     } })</code></pre> <h3>2.2.1 Property-style Access</h3> <p>&nbsp; &nbsp; &nbsp; &nbsp; getters 将其暴露在store.getters 对象上，可以作为属性直接访问</p> <pre><code>store.getters.doneTodos</code></pre> <p>getters还将接收其他getters作为第二个参数</p> <pre><code>getter: {     doneTodosCount:(state,getters) =&gt; {         return getters.doneTodos.length     } }</code></pre> <p>现在，我们可以在任何组件中使用它</p> <pre><code>computed: {     doneTodosCount () {         return this.$store.getters.doneTodosCount     } }</code></pre> <p>注意： 作为属性访问的getters在vuex生态系统中被缓存</p> <h3>2.2.2&nbsp; Method-Style Access</h3> <p>&nbsp; &nbsp; 还可以通过返回函数将参数传递给 getter。当需要查询存储中的数组时，这特别有用</p> <pre><code>getters: {     getTodoById: (state) =&gt; (id) =&gt; {         return state.todos.find(todo =&gt; todo.id === id)     } }  store.getters.getTodoById(2)</code></pre> <h3>2.2.4 mapGetters helper mapGetters助手</h3> <p>&nbsp; &nbsp; &nbsp; &nbsp; mapGetters助手可以简单地将 store中的 getters映射到本地计算属性中</p> <pre><code>import { mapGetters } from 'vuex';  export default {     computed: {         ...mapGetters([             'doneTodosCount',             'anotherGetter'                  ])     } }</code></pre> <p>&nbsp; &nbsp; &nbsp; &nbsp; 你还可以将 一个getter映射为不同的名字，当做一个对象</p> <pre><code>...mapGetters({     doneCount:'doneTodosCount' })</code></pre> <h2>2.3&nbsp; Mutations</h2> <p>&nbsp; &nbsp; &nbsp; &nbsp; 其实在Vuex store中，改变变化的状态，唯一的方法是通过传递一个mutations。Vuex mutations和事件非常相似：每一个mutation有一个type和一个handler。在handler函数中，可以操作实际的state变更，并且它接收这个state作为第一个参数</p> <pre><code>const store = new Vuex.Store({     state: {         count:1     },     mutations: {        increment(state){             state.count ++         }     } })</code></pre> <p>&nbsp; &nbsp; 不能直接调用一个mutation handler。它看起来更像是事件注册。当一个mutation作为type increment被触发，这个handler被调用。为了触发一个mutation handler，你应该调用store.commit作为它的type</p> <pre><code>store.commit('increment')</code></pre> <p><strong>Commit with Payload</strong></p> <p>可以向store.commit 传入额外的参数，即mutation的载荷。在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读：</p> <pre><code>mutations:{     increment(state,n){         state.count+=n;     } }    store.commit('increment',10)</code></pre> <p id="object-style-commit"><strong>Object-Style Commit</strong></p> <p>提交mutation的另一种方式是直接使用包含&nbsp; type 属性的对象</p> <pre><code>store.commit({     type:'increment',     amount: 10 })</code></pre> <p>当使用对象风格的提交方式，整个对象都作为载荷传给 mutation 函数，因此 handler 保持不变：</p> <pre><code>mutations: {     increment(state,payload){         state.count+=payload.amount     } }</code></pre> <p id="mutation-需遵守-vue-的响应规则"><strong>Mutation 需遵守 Vue 的响应规则</strong></p> <p><strong></strong>既然 Vuex 的 store 中的状态是响应式的，那么当我们变更状态时，监视状态的 Vue 组件也会自动更新。这也意味着 Vuex 中的 mutation 也需要与使用 Vue 一样遵守一些注意事项：</p> <ol> <li> <p>最好提前在你的 store 中初始化好所有所需属性。</p> </li> <li> <p>当需要在对象上添加新属性时，你应该</p> </li> </ol> <ul> <li> <p>使用<code>Vue.set(obj, 'newProp', 123)</code>, 或者</p> </li> <li> <p>以新对象替换老对象。例如，利用<a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://github.com/tc39/proposal-object-rest-spread"  rel="nofollow">对象展开运算符&nbsp;(opens new window)</a>我们可以这样写：</p> </li> </ul> <pre><code>state.obj = { ...state.obj, newProp:123 }</code></pre> <p id="使用常量替代-mutation-事件类型"><strong>&nbsp; &nbsp; &nbsp; &nbsp; 使用常量替代 Mutation 事件类型</strong></p> <p>&nbsp; &nbsp; &nbsp; &nbsp; 使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然。在需要多人协作的大型项目中，这会很有帮助。</p> <pre><code>// mutation-types.js export const SOME_MUTATION = 'SOME_MUTATION'  // store.js import Vuex from 'vuex' import { SOME_MUTATION } from './mutation-types'  const store = new Vuex.Store({   state: { ... },   mutations: {     // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名     [SOME_MUTATION] (state) {       // mutate state     }   } })</code></pre> <p id="mutation-必须是同步函数"><strong>Mutation 必须是同步函数</strong></p> <p>一条重要的原则就是要记住<strong>mutation 必须是同步函数</strong>。</p> <pre><code>mutations: {     someMutation(state){         api.callAsyncMethod(() =&gt; {             state.count++         })     } }</code></pre> <p>任何在回调函数中进行的状态的改变都是不可追踪的。</p> <p id="在组件中提交-mutation"><strong>在组件中提交 Mutation</strong></p> <p>可以在组件中使用<code>this.$store.commit('xxx')</code>&nbsp;提交 mutation，或者使用<code>mapMutations</code>&nbsp;辅助函数将组件中的 methods 映射为<code>store.commit</code>&nbsp;调用</p> <pre><code>import { mapMutations } from 'vuex'  export default {     ...mapMutations([         'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')`         'incrementBy'           // 将 `this.incrementBy(amount)` 映射为`this.$store.commit('incrementBy', amount)`     ]),     ...mapMutations([         add:'increment'     ]) }</code></pre> <h3>2.4&nbsp; Action</h3> <p>&nbsp; &nbsp; 在 mutation 中混合异步调用会导致你的程序很难调试。例如，当你调用了两个包含异步回调的 mutation 来改变状态，你怎么知道什么时候回调和哪个先回调呢？在 Vuex 中，<strong>mutation 都是同步事务</strong>：</p> <p>&nbsp; &nbsp;&nbsp;Action 类似于 mutation，不同在于：</p> <ul> <li>Action 提交的是 mutation，而不是直接变更状态。</li> <li>Action 可以包含任意异步操作。</li> </ul> <pre><code>const store = new Vuex.Store({     state: { count:0 },     mutations: {         increment(state){             state.count ++         }     },     actions: {         increment (context){             context.commit('increment')         }     } })</code></pre> <p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用<code>context.commit</code>&nbsp;提交一个 mutation，或者通过<code>context.state</code>&nbsp;和<code>context.getters</code>&nbsp;来获取 state 和 getters。</p> <p><span style="color:#f33b45;">实践中，我们会经常用到 ES2015 的</span><a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://github.com/lukehoban/es6features#destructuring"  rel="nofollow"><span style="color:#f33b45;">参数解构&nbsp;(opens new window)</span></a><span style="color:#f33b45;">来简化代码（特别是我们需要调用<code>commit</code>&nbsp;很多次的时候）：(不太懂)</span></p> <pre><code>actions: {     increment({commit}){         commit('increment')     } }</code></pre> <h3 id="分发-action">2.4.1 分发 Action</h3> <p>&nbsp; &nbsp; &nbsp; &nbsp; Action可以通过 store.dispatch 方法触发</p> <pre><code>store.dispatch('increment')</code></pre> <p>&nbsp; &nbsp; &nbsp; &nbsp; 在action内部可以执行异步可以执行异步操作</p> <pre><code>actions: {     incrementAsync({commit}){         setTimeout(() =&gt; { commit('increment') },1000)     } }</code></pre> <p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Actions 支持同样的载荷方式和对象方式进行分发：</p> <pre><code>store.dispathch('incrementAsync',{     amount:10 })   store.dispatch({     type:'incrementAsybc',     amount: 10 })</code></pre> <p>&nbsp; &nbsp; &nbsp; 复杂案例：涉及到<strong>调用异步 API</strong>&nbsp;和<strong>分发多重 mutation</strong>：</p> <pre><code>actions:{     checkout({ commit, state },products) {         const savedCartItems = [...state.cart.added];         commit(types.CHECKOUT_REQUEST)                  shop.buyProducts(             products,             () =&gt; commit(types.CHECKOUT_SUCCESS)             () =&gt; commit(types.CHECKOUT_FAILURE,savedCartItems)         )      }    }</code></pre> <h3 id="在组件中分发-action">2.4.2 在组件中分发 Action</h3> <p>&nbsp; &nbsp; &nbsp; &nbsp; 在组件中使用<code>this.$store.dispatch('xxx')</code>&nbsp;分发 action，或者使用<code>mapActions</code>&nbsp;辅助函数将组件的 methods 映射为<code>store.dispatch</code>&nbsp;调用（需要先在根节点注入<code>store</code>）</p> <pre><code>import { mapActions } from 'vuex'  export default {     methods: {         ...mapActions([             'increment',                // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`             'incrementBy'                // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`         ]),         ...mapActions([             add:'increment'  // 将 `this.add()` 映射为 `this.$store.dispatch('increment')`         ])     } }</code></pre> <h3 id="组合-action">2.4.3 组合 Action</h3> <p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Action 通常是异步的，action 结束后，处理异步流程。组合多个action，处理更加复杂的异步流程。</p> <p><code>store.dispatch</code>&nbsp;可以处理被触发的 action 的处理函数返回的 Promise，并且<code>store.dispatch</code>&nbsp;仍旧返回 Promise：</p> <pre><code>actions: {     actionA ({ commit }) {         return new Promise((resolve,reject) =&gt; {             setTimeout(() =&gt; { commit('someMutation') },1000)         })     } }    store.dispatch('actionA').then(() =&gt; {})    ///或者  actions: {     actionB({ dispatch,commit }) {         return dispatch('actionA').then(() =&gt; {             commit('someOtherMutation')         })     } }</code></pre> <p>&nbsp; &nbsp; 最后，如果我们利用<a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://tc39.github.io/ecmascript-asyncawait/"  rel="nofollow">async / await&nbsp;(opens new window)</a>，我们可以如下组合 action：</p> <pre><code>actions: {     aync actionA({ commit }){         commit('goData',await getData())     },     async actionB ({ dispatch, commit }){         await dispatch('actionA')         commit('goOtherData', await getOtherData())     } }</code></pre> <p>&nbsp; &nbsp; 一个<code>store.dispatch</code>&nbsp;在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。</p> <h2>2.5 Module</h2> <p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</p> <p>&nbsp; &nbsp; &nbsp; &nbsp; 为了解决以上问题，Vuex 允许我们将 store 分割成<strong>模块（module）</strong>。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：</p> <pre><code>const moduleA = {   state: () =&gt; ({ ... }),   mutations: { ... },   actions: { ... },   getters: { ... } }  const moduleB = {   state: () =&gt; ({ ... }),   mutations: { ... },   actions: { ... } }  const store = new Vuex.Store({   modules: {     a: moduleA,     b: moduleB   } })  store.state.a // -&gt; moduleA 的状态 store.state.b // -&gt; moduleB 的状态</code></pre> <h3>2.5.1&nbsp;模块的局部状态</h3> <p>&nbsp; &nbsp; &nbsp; &nbsp; 对于模块内部的 mutation 和 getter，接收的第一个参数是<strong>模块的局部状态对象</strong>。</p> <pre><code>const moduleA = {   state: () =&gt; ({     count: 0   }),   mutations: {     increment (state) {       // 这里的 `state` 对象是模块的局部状态       state.count++     }   },    getters: {     doubleCount (state) {       return state.count * 2     }   } }</code></pre> <p>&nbsp;&nbsp;同样，对于模块内部的 action，局部状态通过<code>context.state</code>&nbsp;暴露出来，根节点状态则为<code>context.rootState</code>：</p> <pre><code>const moduleA = {   // ...   actions: {     incrementIfOddOnRootSum ({ state, commit, rootState }) {       if ((state.count + rootState.count) % 2 === 1) {         commit('increment')       }     }   } }</code></pre> <p>对于模块内部的 getter，根节点状态会作为第三个参数暴露出来：</p> <pre><code>const moduleA = {   // ...   getters: {     sumWithRootCount (state, getters, rootState) {       return state.count + rootState.count     }   } }</code></pre> <h3>2.5.2&nbsp; 命名空间</h3> <p>&nbsp; &nbsp; &nbsp; &nbsp; 默认情况下，模块内部的 action、mutation 和 getter 是注册在<strong>全局命名空间</strong>的——这样使得多个模块能够对同一 mutation 或 action 作出响应。</p> <p>&nbsp; &nbsp; &nbsp; &nbsp; 如果希望你的模块具有更高的封装度和复用性，你可以通过添加<code>namespaced: true</code>&nbsp;的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。例如：</p> <pre><code>const store = new Vuex.Store({     modules: {         acccount: {             namespace: true,             state: () =&gt; ({}),             getters:{                 isAdmin() {}   // -&gt; getters['account/isAdmin']             },             actions: {                 login() {}   // -&gt; dispatch('account/login')             },             mutations: {                 login() {}   // -&gt; commit('account/login')             },             //嵌套模块             modules: {                 myPage: {                     state: () =&gt; {},                     getters: {                         profile() {} // -&gt; getters['account/profile']                     }                 },                 // 进一步嵌套命名空间                 posts：{                     namespaced: true,                     state: () =&gt; {},                     getters: {                         popular() {...}  // -&gt; getters['account/posts/popular']                     }                 }             }         }     } })</code></pre> <p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;启用了命名空间的 getter 和 action 会收到局部化的<code>getter</code>，<code>dispatch</code>&nbsp;和<code>commit</code>。换言之，你在使用模块内容（module assets）时不需要在同一模块内额外添加空间名前缀。更改<code>namespaced</code>&nbsp;属性后不需要修改模块内的代码。</p> <h3>2.5.2&nbsp;&nbsp;在带命名空间的模块内访问全局内容（Global Assets）</h3> <p>&nbsp; &nbsp; &nbsp; &nbsp; 如果你希望使用全局 state 和 getter，<code>rootState</code>&nbsp;和<code>rootGetters</code>&nbsp;会作为第三和第四参数传入 getter，也会通过<code>context</code>&nbsp;对象的属性传入 action。</p> <p>&nbsp; &nbsp; &nbsp; &nbsp; 若需要在全局命名空间内分发 action 或提交 mutation，将<code>{ root: true }</code>&nbsp;作为第三参数传给<code>dispatch</code>&nbsp;或<code>commit</code>&nbsp;即可。</p> <pre><code>modules: {   foo: {     namespaced: true,      getters: {       // 在这个模块的 getter 中，`getters` 被局部化了       // 你可以使用 getter 的第四个参数来调用 `rootGetters`       someGetter (state, getters, rootState, rootGetters) {         getters.someOtherGetter // -&gt; 'foo/someOtherGetter'         rootGetters.someOtherGetter // -&gt; 'someOtherGetter'       },       someOtherGetter: state =&gt; { ... }     },      actions: {       // 在这个模块中， dispatch 和 commit 也被局部化了       // 他们可以接受 `root` 属性以访问根 dispatch 或 commit       someAction ({ dispatch, commit, getters, rootGetters }) {         getters.someGetter // -&gt; 'foo/someGetter'         rootGetters.someGetter // -&gt; 'someGetter'          dispatch('someOtherAction') // -&gt; 'foo/someOtherAction'         dispatch('someOtherAction', null, { root: true }) // -&gt; 'someOtherAction'          commit('someMutation') // -&gt; 'foo/someMutation'         commit('someMutation', null, { root: true }) // -&gt; 'someMutation'       },       someOtherAction (ctx, payload) { ... }     }   } }</code></pre> <h3>2.5.3 在带命名空间的模块注册全局 action</h3> <p>&nbsp; &nbsp; &nbsp; &nbsp; 若需要在带命名空间的模块注册全局 action，你可添加<code>root: true</code>，并将这个 action 的定义放在函数<code>handler</code>&nbsp;中。例如：</p> <pre><code>{   actions: {     someOtherAction ({dispatch}) {       dispatch('someAction')     }   },   modules: {     foo: {       namespaced: true,        actions: {         someAction: {           root: true,           handler (namespacedContext, payload) { ... } // -&gt; 'someAction'         }       }     }   } }</code></pre> <h3>2.5.4&nbsp;带命名空间的绑定函数</h3> <p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;当使用<code>mapState</code>,<code>mapGetters</code>,<code>mapActions</code>&nbsp;和<code>mapMutations</code>&nbsp;这些函数来绑定带命名空间的模块时，写起来可能比较繁琐：</p> <pre><code>computed: {   ...mapState({     a: state =&gt; state.some.nested.module.a,     b: state =&gt; state.some.nested.module.b   }) }, methods: {   ...mapActions([     'some/nested/module/foo', // -&gt; this['some/nested/module/foo']()     'some/nested/module/bar' // -&gt; this['some/nested/module/bar']()   ]) }</code></pre> <p>&nbsp; &nbsp; &nbsp; &nbsp; 对于这种情况，你可以将模块的空间名称字符串作为第一个参数传递给上述函数，这样所有绑定都会自动将该模块作为上下文。</p> <pre><code>computed: {     ...mapState('some/nested/module',{         a: state =&gt; state.a,         b: state =&gt; state.b     }) },  method: {     ...mapActions('some/nested/module',{         'foo',         'bar'     }) }</code></pre> <p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;可以通过使用<code>createNamespacedHelpers</code>&nbsp;创建基于某个命名空间辅助函数。它返回一个对象，对象里有新的绑定在给定命名空间值上的组件绑定辅助函数：</p> <pre><code>import { createNamespacedHelpers } from 'vuex'  const { mapState, mapAction } = createNamespacecdHelper('some/nested/module')  export default {     computed: {         ...mapState({             a: state =&gt; state.a,             b: state =&gt; state.b         })     },     method: {         ...mapActions([             'foo',             'bar'         ])     } }</code></pre> <p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;如果你开发的<a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://vuex.vuejs.org/zh/guide/plugins.html"  rel="nofollow">插件（Plugin）</a>提供了模块并允许用户将其添加到 Vuex store，可能需要考虑模块的空间名称问题。对于这种情况，你可以通过插件的参数对象来允许用户指定空间名称</p> <pre><code>export function createPlugin(options ={}){     return function(store){         const namespace = options.namespace || '';         store.dispatch(namespace + 'pluginAction')     } }</code></pre> <h3>2.5.5模块动态注册</h3> <p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;在 store 创建<strong>之后</strong>，你可以使用<code>store.registerModule</code>&nbsp;方法注册模块：</p> <pre><code>import Vuex from 'vuex'  const store = new Vuex.Store({})  // 注册模块 `myModule`  store.registerModule('myModule',{})   // 注册嵌套模块 `nested/myModule` store.registerModule(['nested','myNodule'],{})</code></pre> <p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;之后就可以通过<code>store.state.myModule</code>&nbsp;和<code>store.state.nested.myModule</code>&nbsp;访问模块的状态。</p> <p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;模块动态注册功能使得其他 Vue 插件可以通过在 store 中附加新模块的方式来使用 Vuex 管理状态。例如，<a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://github.com/vuejs/vuex-router-sync"  rel="nofollow"><code>vuex-router-sync</code>&nbsp;(opens new window)</a>插件就是通过动态注册模块将 vue-router 和 vuex 结合在一起，实现应用的路由状态管理。</p> <p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;使用<code>store.unregisterModule(moduleName)</code>&nbsp;来动态卸载模块。注意，你不能使用此方法卸载静态模块（即创建 store 时声明的模块）。</p> <p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;可以通过<code>store.hasModule(moduleName)</code>&nbsp;方法检查该模块是否已经被注册到 store</p> <h3>2.5.6&nbsp; 保留state</h3> <p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;在注册一个新 module 时，你很有可能想保留过去的 state，例如从一个服务端渲染的应用保留 state。你可以通过<code>preserveState</code>&nbsp;选项将其归档：<code>store.registerModule('a', module, { preserveState: true })</code>。</p> <p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;当你设置<code>preserveState: true</code>&nbsp;时，该模块会被注册，action、mutation 和 getter 会被添加到 store 中，但是 state 不会。</p> <h2>2.5.7&nbsp; 模块重用</h2> <p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;有时我们可能需要创建一个模块的多个实例</p> <ul> <li>创建多个 store，他们公用同一个模块 (例如当<code>runInNewContext</code>&nbsp;选项是<code>false</code>&nbsp;或<code>'once'</code>&nbsp;时，为了<a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://ssr.vuejs.org/en/structure.html#avoid-stateful-singletons"  rel="nofollow">在服务端渲染中避免有状态的单例&nbsp;(opens new window)</a>)</li> <li>在一个 store 中多次注册同一个模块</li> </ul> <p>&nbsp; &nbsp;如果使用一个纯对象来声明模块的状态，那么这个状态对象会通过引用被共享，导致状态对象被修改时 store 或模块间数据互相污染的问题。</p> <p>&nbsp; &nbsp; &nbsp; &nbsp; 实际上这和 Vue 组件内的<code>data</code>&nbsp;是同样的问题。因此解决办法也是相同的——使用一个函数来声明模块状态（仅 2.3.0+ 支持）</p> <pre><code>const MyReusableModule = {     state: ()=&gt; {          foo:'bar'     }, }</code></pre> </h1> <p>&nbsp; &nbsp; &nbsp; &nbsp; Vuex不限制代码结构。但是，它规定了一些需要遵守的原则</p> <ol> <li>应用层级的状态应该集中到单个store对象中</li> <li>提交 mutation 是更改状态的唯一方法，并且这个过程是同步的</li> <li>异步逻辑都应封装到action里面</li> </ol> <p>&nbsp; &nbsp; &nbsp; &nbsp; 如果 store 文件太大，只需将 action、mutation 和 getter 分割到单独的文件。</p> <p><img loading="lazy" decoding="async" alt="" height="359" src="http://img.555519.xyz/uploads3/20220606/f721077dfd4924f76f3722f7915eed53.jpg"></p> <h2>3.1 插件</h2> <p>store使用插件</p> <pre><code>const store = new Vuex.Store({   // ...   plugins: [myPlugin] })</code></pre> <p>Vuex 的 store 接受<code>plugins</code>&nbsp;选项，这个选项暴露出每次 mutation 的钩子。Vuex 插件就是一个函数，它接收 store 作为唯一参数：</p> <h2>3.2&nbsp;在插件内提交 Mutation</h2> <p>&nbsp; &nbsp; &nbsp; &nbsp; 在插件中不允许直接修改状态——类似于组件，只能通过提交 mutation 来触发变化。</p> <p>通过提交 mutation，插件可以用来同步数据源到 store。例如，同步 websocket 数据源到 store（下面是个大概例子，实际上<code>createPlugin</code>&nbsp;方法可以有更多选项来完成复杂任务）</p> <pre><code>export default function createWebSocketPlugin (socket) {   return store =&gt; {     socket.on('data', data =&gt; {       store.commit('receiveData', data)     })     store.subscribe(mutation =&gt; {       if (mutation.type === 'UPDATE_DATA') {         socket.emit('update', mutation.payload)       }     })   } }</code></pre> <pre><code>const plugin = createWebSocketPlugin(socket)  const store = new Vuex.Store({   state,   mutations,   plugins: [plugin] })</code></pre> <h2>3.3&nbsp; 生产 state快照</h2> <p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;有时候插件需要获得状态的“快照”，比较改变的前后状态。想要实现这项功能，你需要对状态对象进行深拷贝：</p> <pre><code>const myPluginWithSnapshot = store =&gt; {   let prevState = _.cloneDeep(store.state)   store.subscribe((mutation, state) =&gt; {     let nextState = _.cloneDeep(state)      // 比较 prevState 和 nextState...      // 保存状态，用于下一次 mutation     prevState = nextState   }) }</code></pre> <p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 生成状态快照的插件应该只在开发阶段使用</strong>，使用 webpack 或 Browserify，让构建工具帮我们处理：</p> <pre><code>const store = new Vuex.Store({     plugins: process.env.NODE_ENV !== 'production'     ? [myPluginWidthSnapshot]     : [] })</code></pre> <p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;上面插件会默认启用。在发布阶段，你需要使用 webpack 的<a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://webpack.js.org/plugins/define-plugin/"  rel="nofollow">DefinePlugin&nbsp;(opens new window)</a>或者是 Browserify 的<a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://github.com/hughsk/envify"  rel="nofollow">envify&nbsp;(opens new window)</a>使<code>process.env.NODE_ENV !== 'production'</code>&nbsp;为<code>false</code>。</p> <h2>3.2&nbsp; 内置Logger插件</h2> <p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Vuex 自带一个日志插件用于一般的调试:</p> <pre><code>import createLogger from 'vuex/dist/logger'  const store = new Vuex.Store({     plugins:[createLogger] })   const logger = createLogger({     collapsed: false,     filter(mutation, stateBefore, stateAfter){         return mutation.type !== 'BlocklistedMutation'     },     actionFilter (action, state) {       // 和 `filter` 一样，但是是针对 action 的       // `action` 的格式是 `{ type, payload }`       return action.type !== "aBlocklistedAction"     },      transformer (state) {     // 在开始记录之前转换状态     // 例如，只返回指定的子树     return state.subTree   },   mutationTransformer (mutation) {     // mutation 按照 { type, payload } 格式记录     // 我们可以按任意方式格式化     return mutation.type   },   actionTransformer (action) {     // 和 `mutationTransformer` 一样，但是是针对 action 的     return action.type   },   logActions: true, // 记录 action 日志   logMutations: true, // 记录 mutation 日志   logger: console, // 自定义 console 实现，默认为 `console`  })</code></pre> </div> 			                <div class="clearfix"></div>
                <div class="col-md-12 mt-5">
                                        <p>上一个：<a href="/news/article-86067.htm">江苏领养猫咪（江阴领养猫）</a></p>
                                        <p>下一个：<a href="/news/article-86774.htm">动物医院诊疗范围包括什么 动物医院诊疗范围包括什么内容</a></p>
                                    </div>
                                    </div>
                    <div class="col-md-3">
                        <div class="panel panel-default">
                            <div class="panel-heading">
                                <h3 class="panel-title">热门文章</h3>
                            </div>
                            <div class="panel-body">
                                <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                                    <li class="py-2"><a href="/free-nodes/2024-5-8-clash-v2ray-ss-ssr.htm" title="5月8日|最高速度22.5M/S，2024最新Shadowrocket/Clash/SSR/V2ray免费节点高速订阅链接">5月8日|最高速度22.5M/S，2024最新Shadowrocket/Clash/SSR/V2ray免费节点高速订阅链接</a></li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>
                <!-- Start of Footer Area -->
        <footer id="footer" class="footer-area footer-bg">
            <div class="footer-bottom-area">
                <div class="container">
                    <div class="row">
                        <div class="col-xs-12 col-sm-6 col-md-6 col-lg-6">
                            <div class="copy-right-text">
                            <p>
                                <a href="/">首页</a> | 
                                <a href="/free-node/">免费节点</a> | 
                                <a href="/news/">新闻资讯</a> |
                                <a href="/about-us.htm">关于我们</a> |
                                <a href="/disclaimer.htm">免责申明</a> |
                                <a href="/privacy.htm">隐私申明</a> |
                                <a href="/sitemap.xml">网站地图</a>
                            </p>
                                NodeClashV2ray节点订阅站 版权所有 Powered by WordPress
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </footer>
        <!--End of Footer Area -->
    </div>
    <!-- Body main wrapper end -->
    <!-- Placed js at the end of the document so the pages load faster -->
    <!-- jquery latest version -->
    <script src="/assets/website/js/frontend/nodeclashv2ray/vendor/jquery-1.12.0.min.js"></script>
    <!-- Bootstrap framework js -->
    <script src="/assets/website/js/frontend/nodeclashv2ray/bootstrap.min.js"></script>
    <!-- Owl Carousel framework js -->
    <script src="/assets/website/js/frontend/nodeclashv2ray/owl.carousel.min.js"></script>
    <!-- All js plugins included in this file. -->
    <script src="/assets/website/js/frontend/nodeclashv2ray/plugins.js"></script>
    <!-- Slick min.js. -->
    <script src="/assets/website/js/frontend/nodeclashv2ray/slick.min.js"></script>
    <!-- Waypoints.min.js. -->
    <script src="/assets/website/js/frontend/nodeclashv2ray/waypoints.min.js"></script>
    <!-- Main js file that contents all jQuery plugins activation. -->
    <script src="/assets/website/js/frontend/nodeclashv2ray/main.js"></script>
    <script src="https://www.freeclashnode.com/assets/js/frontend/invite-url.js"></script><script src="/assets/website/js/frontend/G.js"></script>
</body>

</html>